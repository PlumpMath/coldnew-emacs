#+TITLE: Clojure Development
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+DESCRIPTION: Clojure programming language setup

#+SETUPFILE: configs.setup


#+BEGIN_SRC emacs-lisp :noweb no-export
  (use-package clojure-mode
    :ensure t
    :config
    <<clojure-config>>)
#+END_SRC

* Install Clojure's building system: Leinigen

We don't need to install [[https://clojure.org][Clojure]] to our system directly, we just install the building system: [[http://leiningen.org/][Leinigen]].

[[http://leiningen.org/][Leinigen]] is a tool to help you automating Clojure projects.

** Install Leinigen

To install it, you need to download the [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] (on on Windows [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein.bat][lein.bat]]) to your system, I always put it on =~/bin= folder.

#+BEGIN_SRC sh :tangle no
  mkdir -p ~/bin
  wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein -O ~/bin/lein && chmod +x $_
#+END_SRC

Don't forget change =lein= to executable script (=chmod +x=) and makre sure you =~/bin= is in your =$PATH= environment variables.

#+BEGIN_SRC sh :tangle no
  export PATH="~/bin:$PATH"
#+END_SRC

After all things done, we can use [[http://leiningen.org/][Leinigen]] to create our first Clojure project:

: lein new hellowrold

[[http://leiningen.org/][Leinigen]] will create a sample project with this directory structure

#+BEGIN_EXAMPLE  :tangle no
.
├── CHANGELOG.md
├── LICENSE
├── README.md
├── doc
│   └── intro.md
├── project.clj
├── resources
├── src
│   └── hellowrold
│       └── core.clj
└── test
    └── hellowrold
        └── core_test.clj

6 directories, 7 files
#+END_EXAMPLE

Just modify the =src/hellowrold/core.clj= like this

#+BEGIN_SRC clojure  :tangle no
  (ns hellowrold.core)

  (defn -main []
    (println "Hello Clojure!!!"))
#+END_SRC

Then use =lein run -m hello.core= to execute our main function

#+BEGIN_SRC sh  :tangle no
  lein run -m hello.core
  Hello, Clojure!!!
#+END_SRC

YA! Our first Clojure project is work :).

** Setup your leinigen profiles

After we install leinigen, we need to add =cider-nrepl= and =refactor-nrepl= to your lein profile.

Create =~/.lein/profiles.clj= with following content:

#+BEGIN_SRC clojure :tangle no
  {:repl {:plugins [[cider/cider-nrepl "0.10.0-SNAPSHOT"]
                    [refactor-nrepl "2.0.0-SNAPSHOT"]]
          :dependencies [[alembic "0.3.2"]
                         [org.clojure/tools.nrepl "0.2.12"]]}}
#+END_SRC

* Install Clojure's building system: boot

[[http://boot-clj.com/][Boot]] is another building tool for Clojure.

** Install Boot

To install it, you need to download the [[https://github.com/boot-clj/boot-bin/releases/download/latest/boot.sh][boot script]] to your system, I always put it on =~/bin= folder.

#+BEGIN_SRC sh :tangle no
  mkdir -p ~/bin
  curl -fsSLo ~/bin/boot https://github.com/boot-clj/boot-bin/releases/download/latest/boot.sh
  && chmod +x $_
#+END_SRC

Don't forget change =lein= to executable script (=chmod +x=) and makre sure you =~/bin= is in your =$PATH= environment variables.

#+BEGIN_SRC sh :tangle no
  export PATH="~/bin:$PATH"
#+END_SRC

Now we can use =boot repl= to start clojure's repl for test

#+BEGIN_SRC sh :tangle no
  boot repl
#+END_SRC

* Use cider for interactive development

[[https://github.com/clojure-emacs/cider][cider]] is a Clojure Interactive Development Environment that Rocks for Emacs

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref clojure-config
  (use-package cider
    :ensure t
    :config

    ;; Enable eldoc in Clojure buffers
    (add-hook 'cider-mode-hook 'eldoc-mode)

    ;; Hide `*nrepl-connection*' and `*nrepl-server*' buffers from appearing
    ;; in some buffer switching commands like switch-to-buffer
    (setq nrepl-hide-special-buffers t)

    ;; Enabling CamelCase support for editing commands(like forward-word,
    ;; backward-word, etc) in the REPL is quite useful since we often have
    ;; to deal with Java class and method names. The built-in Emacs minor
    ;; mode subword-mode provides such functionality
    (add-hook 'cider-repl-mode-hook #'subword-mode)

    ;; The use of paredit when editing Clojure (or any other Lisp) code is
    ;; highly recommended. You're probably using it already in your
    ;; clojure-mode buffers (if you're not you probably should). You might
    ;; also want to enable paredit in the REPL buffer as well.
    ;; (add-hook 'cider-repl-mode-hook #'paredit-mode)

    ;; Auto-select the error buffer when it's displayed:
    (setq cider-auto-select-error-buffer t)

    ;; Controls whether to pop to the REPL buffer on connect.
    (setq cider-repl-pop-to-buffer-on-connect nil)

    ;; Make cider not prompt to save the corresponding file when loading a buffer.
    (setq cider-prompt-save-file-on-load nil)

    ;; T to wrap history around when the end is reached.
    (setq cider-repl-wrap-history t)

    ;; Log protocol messages to the `nrepl-message-buffer-name' buffer.
    (setq nrepl-log-messages t))
#+END_SRC

* Add refactor function support

GitHub: https://github.com/clojure-emacs/clj-refactor.el

#+BEGIN_SRC emacs-lisp
  (use-package clj-refactor
    :ensure t
    :config
    ;; Add clj-refactor to clojure-mode
    (add-hook 'clojure-mode-hook '(lambda () (clj-refactor-mode 1)))
    ;; Use `C-c C-x' as prefix
    (cljr-add-keybindings-with-prefix "M-m"))
#+END_SRC

* Search on Clojars more easily

This Emacs extension allows you to search for projects on clojars.org
and copies your selection to the kill ring in a format suitable for
your =project.clj=.

GitHub: https://github.com/joshuamiller/clojars.el

#+BEGIN_SRC emacs-lisp
  (use-package clojars
    :ensure t)
#+END_SRC

* Search Clojure Cheatsheet

GitHub: https://github.com/clojure-emacs/clojure-cheatsheet

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref clojure-config
  (use-package clojure-cheatsheet
    :ensure t)
#+END_SRC

* Pretty Symbols

Pretty symbols for anonymous functions, set literals and partial, like =(λ [a] (+ a 5))=, =ƒ(+ % 5)=, =∈{2 4 6}= and =Ƥ=.

#+BEGIN_SRC emacs-lisp
  (defun my/clojure/fancify-symbols (mode)
    "Pretty symbols for Clojure's anonymous functions and sets,
     like (λ [a] (+ a 5)), ƒ(+ % 5), and ∈{2 4 6}."
    (font-lock-add-keywords mode
                            `(("(\\(fn\\)[\[[:space:]]"
                               (0 (progn (compose-region (match-beginning 1)
                                                         (match-end 1) "λ"))))
                              ("(\\(partial\\)[\[[:space:]]"
                               (0 (progn (compose-region (match-beginning 1)
                                                         (match-end 1) "Ƥ"))))
                              ("(\\(comp\\)[\[[:space:]]"
                               (0 (progn (compose-region (match-beginning 1)
                                                         (match-end 1) "∘"))))
                              ("\\(#\\)("
                               (0 (progn (compose-region (match-beginning 1)
                                                         (match-end 1) "ƒ"))))
                              ("\\(#\\){"
                               (0 (progn (compose-region (match-beginning 1)
                                                         (match-end 1) "∈")))))))

  (dolist (m '(clojure-mode clojurescript-mode clojurec-mode clojurex-mode cider-repl-mode))
    (my/clojure/fancify-symbols m))
#+END_SRC

* Interactive Commands                                              :command:

Some interactive commands for clojure-mode.

** Send S-Expression and evaluate it there

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref clojure-config
  (defun my/cider-send-and-evaluate-sexp ()
    "Sends the s-expression located before the point or the active
    region to the REPL and evaluates it. Then the Clojure buffer is
    activated as if nothing happened."
    (interactive)
    (if (not (region-active-p))
        (cider-insert-last-sexp-in-repl)
      (cider-insert-in-repl
       (buffer-substring (region-beginning) (region-end)) nil))
    (cider-switch-to-repl-buffer)
    (cider-repl-closing-return)
    (cider-switch-to-last-clojure-buffer)
    (message ""))
#+END_SRC

* Setup Clojure Keybindings                                      :keybinding:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref clojure-config
  (bind-keys :map clojure-mode-map
             ;; M-m     . refactor command
             ("C-c C-f" . projectile-find-file)
             ("C-c M-c" . cider-connect)
             ("C-c M-j" . cider-jack-in)
             ("C-c '"   . my/narrow-or-widen-dwim)
             ("C-c h"   . clojure-cheatsheet)
             ("C-c C-k" . cider-load-buffer)
             ("C-x C-e" . cider-eval-last-sexp)
             ("C-c C-v" . my/cider-send-and-evaluate-sexp)
             ("C-c C-t" . projectile-toggle-between-implementation-and-test))
#+END_SRC
